#include "utils.h"

extern char *vulnerable_c_functions[];
extern char *vuln_func_info[];

// Stores the vulnerabilities found.
char vuln_found[4000];

// Stores the memory leak vulnerabilities found.
char vuln_mem_leak[4000];

// Stores the information about the vulnerable string found.
char *info[5];

char vuln_string_func_found = 'n';
	
// Initialize the info array setting each index to null character.
void init_info_arr()
{
	for(int i=0; i<5; ++i) info[i] = '\0';
}
	
void banner()
{
	system("clear");
	printf("\033[1;32m\n\t\t\t\t|VULNERABILITY SCANNER|\033[0m\n");
	printf("\033[1;34m\n\t\t\tAuthor:\033[0m \033[0;34mOdey John Ebinyi\033[0m\n");
	printf("\033[1;34m\t\t\tTwitter:\033[0m \033[0;34m@i_am_giannis\033[0m\n");
	printf("\033[1;34m\t\t\tVersion:\033[0m \033[0;34m1.0 (c) 2023\033[0m\n\n");
	printf("\033[1;34m\t\t\tDescription:\033[0m\t\033[0;34mThis program assesses a C program by checking\n\t\t\t\t\tand reporting any vulnerablility found!.\033[0m\n\n");
}

void help()
{	
	unsigned short int i = 0;
	printf("\033[1;36m\n\nSolution: \n\033[0m");
	while(info[i]) 
	{
		printf("\033[1;36m(%d) %s\033[0m\n\n", (i+1), info[i]);
		++i;
	}
}

// This takes in the filename and returns a boolean
// whenever a memory leak is found.
bool check_mem_leak(const char *filename)
{
	// We need to open the file for reading.
    FILE *fp = fopen(filename, "r");
    unsigned int malloc_counter = 0, free_counter = 0;
    char word[100];
    
    if(fp == NULL)
    {
		fprintf(stderr, "\033[1;31m\nERROR: The filename \'(%s)\' does not exist for reading\033[0m", filename);
		exit(EXIT_FAILURE);
	}
    
	// Read each word from the source code
	while(fscanf(fp, "%s", word) != EOF)
	{
		if(strstr(word, "malloc"))
			++malloc_counter;
		if(strstr(word, "free"))
			++free_counter;
	} 
	
	if(malloc_counter == free_counter)
		return true;
	else
	{
		sprintf(vuln_mem_leak + strlen(vuln_mem_leak), "cat -n %s | grep \"malloc\";", filename);
	}
	
	if(fclose(fp) != 0)
	{
		fprintf(stderr, "Error in closing file\n");
		exit(EXIT_FAILURE);
	}
}

// This function takes in a filename and the buffer, @word, containing the vulnerable string
// function found
void vuln_check(const char *filename, const char *word)
{
	int counter;
	static int info_index = 0;

	for(counter = 0; counter < 5; ++counter)
	{
		// Since i am using strstr(), it returns gets() and fgets(). But fgets() is safer
		// than gets(). Hence, if fgets() is found, break.
		if(strstr(word, "fgets")) break;
		
		if(strstr(word, vulnerable_c_functions[counter]))
		{
			if(strchr(word, LEFT_PARENTHESIS))
			{
				// vulnerable string found, set it to (y)es.
				vuln_string_func_found = 'y';
				
				// Store information of why the string is vulnerable into the info[] array of strings
				info[info_index] = vuln_func_info[counter];
				
				// Increase the index whenever a vulnerable string is found, to keep track of the 
				// specific index in info to display to the user.
				++info_index;
				
				sprintf(vuln_found, "cat -n %s | grep %s;", filename, vulnerable_c_functions[counter]);
		
				sleep(2);
		
				for(int i = 1; i < 100; ++i) printf("+");
				printf("\033[1;31m\nVulnerabilities in \"%s\":\033[0m\n\n", filename);
				system(vuln_found);
				for(int i = 1; i < 100; ++i) printf("+");
				printf("\n");
				
				break;
			}
		}
	}
}

// This program opens the source code file for reading and calls the function
// vuln_check() with each word as argument to check for vulnerable String functions.
void read_program_file(const char *filename, char *word)
{
    // We need to open the file for reading.
    FILE *fp = fopen(filename, "r");

    if(fp == NULL)
    {
		fprintf(stderr, "\033[1;31m\nERROR: The filename \'(%s)\' does not exist for reading\033[0m", filename);
		exit(EXIT_FAILURE);
	}
    
	// Read each word from the source code
	while(fscanf(fp, "%s", word) != EOF)
	{
		vuln_check(filename, word);
	} 

	if(vuln_string_func_found == 'y')
		help();
	else
		printf("\033[1;32m\nNo vulnerable C string functions found!");

	if(!check_mem_leak(filename))
	{
		for(int i = 1; i < 100; ++i) printf("+");
		printf("\033[1;31m\n\nMemory leak in \"%s\"(No associated free() function(s)):\033[0m\n\n", filename);
		system(vuln_mem_leak);
		for(int i = 1; i < 100; ++i) printf("+");
	}
	
	if(fclose(fp) != 0)
	{
		fprintf(stderr, "Error in closing file\n");
		exit(EXIT_FAILURE);
	}
	
	printf("\033[1;32m\n\n\t -- Bye friend!\033[0m\n");
}

// This function returns the file type. By default, it only works with
// C and C++. It returns "unknown" for other file types.
const char *get_file_type(const char* filename) 
{
    const char *last_dot = strrchr(filename, '.');
    if (last_dot) 
    {
        if (strcmp(last_dot, ".c") == 0) return "C source code file";
        if (strcmp(last_dot, ".cpp") == 0) return "C++ source code file";
        if (strcmp(last_dot, ".py") == 0) return "Python source code file";
    }

    return "unknown";
}

/*
 * Copy string src to buffer dst of size dsize. At most dsize-1
 * chars will be copied. Always NUL terminates (unless dsize == 0).
 * Returns strlen(src); if retval >= dsize, truncation occured.
 */
size_t strlcpy(char * __restrict dst, const char *__restrict src, size_t dsize)
{
	const char *osrc = src;
	size_t nleft = dsize;
	
	/* Copy as many bytes as will fit. */
	if(nleft != 0)
	{
		while(--nleft != 0)
		{
			if((*dst++ = *src++) == '\0')
				break;
		}
	}
	
	/* Not enough room in dst, add NUL and traverse rest of src. */
	if(nleft == 0)
	{
		if(dsize != 0)
			*dst = '\0';
		while(*src++)
			;
	}
	
	return(src - osrc - 1); /* count does not include NUL */
}
